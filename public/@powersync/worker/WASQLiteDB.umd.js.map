{"version":3,"file":"worker/WASQLiteDB.umd.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC56BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACRA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://sdk_web/./lib/src/shared/navigator.js","webpack://sdk_web/./lib/src/shared/open-db.js","webpack://sdk_web/../../node_modules/async-mutex/index.mjs","webpack://sdk_web/../../node_modules/comlink/dist/esm/comlink.mjs","webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/sqlite-api.js","webpack://sdk_web/../../node_modules/@journeyapps/wa-sqlite/src/sqlite-constants.js","webpack://sdk_web/webpack/bootstrap","webpack://sdk_web/webpack/runtime/define property getters","webpack://sdk_web/webpack/runtime/ensure chunk","webpack://sdk_web/webpack/runtime/get javascript chunk filename","webpack://sdk_web/webpack/runtime/global","webpack://sdk_web/webpack/runtime/hasOwnProperty shorthand","webpack://sdk_web/webpack/runtime/make namespace object","webpack://sdk_web/webpack/runtime/publicPath","webpack://sdk_web/webpack/runtime/importScripts chunk loading","webpack://sdk_web/./lib/src/worker/db/WASQLiteDB.worker.js"],"sourcesContent":["export const getNavigatorLocks = () => {\n    if ('locks' in navigator && navigator.locks) {\n        return navigator.locks;\n    }\n    throw new Error('Navigator locks are not available in an insecure context. Use a secure context such as HTTPS or http://localhost.');\n};\n","import '@journeyapps/wa-sqlite';\nimport * as SQLite from '@journeyapps/wa-sqlite';\nimport { Mutex } from 'async-mutex';\nimport * as Comlink from 'comlink';\nlet nextId = 1;\nexport async function _openDB(dbFileName, options = { useWebWorker: true }) {\n    const { default: moduleFactory } = await import('@journeyapps/wa-sqlite/dist/wa-sqlite-async.mjs');\n    const module = await moduleFactory();\n    const sqlite3 = SQLite.Factory(module);\n    /**\n     * Register the PowerSync core SQLite extension\n     */\n    module.ccall('powersync_init_static', 'int', []);\n    const { IDBBatchAtomicVFS } = await import('@journeyapps/wa-sqlite/src/examples/IDBBatchAtomicVFS.js');\n    // @ts-expect-error The types for this static method are missing upstream\n    const vfs = await IDBBatchAtomicVFS.create(dbFileName, module, { lockPolicy: 'exclusive' });\n    sqlite3.vfs_register(vfs, true);\n    const db = await sqlite3.open_v2(dbFileName);\n    const statementMutex = new Mutex();\n    /**\n     * Listeners are exclusive to the DB connection.\n     */\n    const listeners = new Map();\n    let updatedTables = new Set();\n    let updateTimer = null;\n    function fireUpdates() {\n        updateTimer = null;\n        const event = { tables: [...updatedTables], groupedUpdates: {}, rawUpdates: [] };\n        updatedTables.clear();\n        Array.from(listeners.values()).forEach((l) => l(event));\n    }\n    sqlite3.update_hook(db, (updateType, dbName, tableName) => {\n        if (!tableName) {\n            return;\n        }\n        updatedTables.add(tableName);\n        if (updateTimer == null) {\n            updateTimer = setTimeout(fireUpdates, 0);\n        }\n    });\n    /**\n     * This executes single SQL statements inside a requested lock.\n     */\n    const execute = async (sql, bindings) => {\n        // Running multiple statements on the same connection concurrently should not be allowed\n        return _acquireExecuteLock(async () => {\n            return executeSingleStatement(sql, bindings);\n        });\n    };\n    /**\n     * This requests a lock for executing statements.\n     * Should only be used internally.\n     */\n    const _acquireExecuteLock = (callback) => {\n        return statementMutex.runExclusive(callback);\n    };\n    /**\n     * This executes a single statement using SQLite3.\n     */\n    const executeSingleStatement = async (sql, bindings) => {\n        const results = [];\n        for await (const stmt of sqlite3.statements(db, sql)) {\n            let columns;\n            const wrappedBindings = bindings ? [bindings] : [[]];\n            for (const binding of wrappedBindings) {\n                // TODO not sure why this is needed currently, but booleans break\n                binding.forEach((b, index, arr) => {\n                    if (typeof b == 'boolean') {\n                        arr[index] = b ? 1 : 0;\n                    }\n                });\n                sqlite3.reset(stmt);\n                if (bindings) {\n                    sqlite3.bind_collection(stmt, binding);\n                }\n                const rows = [];\n                while ((await sqlite3.step(stmt)) === SQLite.SQLITE_ROW) {\n                    const row = sqlite3.row(stmt);\n                    rows.push(row);\n                }\n                columns = columns ?? sqlite3.column_names(stmt);\n                if (columns.length) {\n                    results.push({ columns, rows });\n                }\n            }\n            // When binding parameters, only a single statement is executed.\n            if (bindings) {\n                break;\n            }\n        }\n        const rows = [];\n        for (const resultset of results) {\n            for (const row of resultset.rows) {\n                const outRow = {};\n                resultset.columns.forEach((key, index) => {\n                    outRow[key] = row[index];\n                });\n                rows.push(outRow);\n            }\n        }\n        const result = {\n            insertId: sqlite3.last_insert_id(db),\n            rowsAffected: sqlite3.changes(db),\n            rows: {\n                _array: rows,\n                length: rows.length\n            }\n        };\n        return result;\n    };\n    /**\n     * This executes SQL statements in a batch.\n     */\n    const executeBatch = async (sql, bindings) => {\n        return _acquireExecuteLock(async () => {\n            let affectedRows = 0;\n            try {\n                await executeSingleStatement('BEGIN TRANSACTION');\n                const wrappedBindings = bindings ? bindings : [];\n                for await (const stmt of sqlite3.statements(db, sql)) {\n                    if (stmt === null) {\n                        return {\n                            rowsAffected: 0,\n                            rows: { _array: [], length: 0 }\n                        };\n                    }\n                    //Prepare statement once\n                    for (const binding of wrappedBindings) {\n                        // TODO not sure why this is needed currently, but booleans break\n                        for (let i = 0; i < binding.length; i++) {\n                            const b = binding[i];\n                            if (typeof b == 'boolean') {\n                                binding[i] = b ? 1 : 0;\n                            }\n                        }\n                        if (bindings) {\n                            sqlite3.bind_collection(stmt, binding);\n                        }\n                        const result = await sqlite3.step(stmt);\n                        if (result === SQLite.SQLITE_DONE) {\n                            //The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero.\n                            affectedRows += sqlite3.changes(db);\n                        }\n                        sqlite3.reset(stmt);\n                    }\n                }\n                await executeSingleStatement('COMMIT');\n            }\n            catch (err) {\n                await executeSingleStatement('ROLLBACK');\n                return {\n                    rowsAffected: 0,\n                    rows: { _array: [], length: 0 }\n                };\n            }\n            const result = {\n                rowsAffected: affectedRows,\n                rows: { _array: [], length: 0 }\n            };\n            return result;\n        });\n    };\n    if (options.useWebWorker) {\n        const registerOnTableChange = (callback) => {\n            const id = nextId++;\n            listeners.set(id, callback);\n            return Comlink.proxy(() => {\n                listeners.delete(id);\n            });\n        };\n        return {\n            execute: Comlink.proxy(execute),\n            executeBatch: Comlink.proxy(executeBatch),\n            registerOnTableChange: Comlink.proxy(registerOnTableChange),\n            close: Comlink.proxy(() => {\n                sqlite3.close(db);\n            })\n        };\n    }\n    const registerOnTableChange = (callback) => {\n        const id = nextId++;\n        listeners.set(id, callback);\n        return () => {\n            listeners.delete(id);\n        };\n    };\n    return {\n        execute: execute,\n        executeBatch: executeBatch,\n        registerOnTableChange: registerOnTableChange,\n        close: () => sqlite3.close(db)\n    };\n}\n","const E_TIMEOUT = new Error('timeout while waiting for mutex to become available');\nconst E_ALREADY_LOCKED = new Error('mutex already locked');\nconst E_CANCELED = new Error('request for lock canceled');\n\nvar __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Semaphore {\n    constructor(_value, _cancelError = E_CANCELED) {\n        this._value = _value;\n        this._cancelError = _cancelError;\n        this._weightedQueues = [];\n        this._weightedWaiters = [];\n    }\n    acquire(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve, reject) => {\n            if (!this._weightedQueues[weight - 1])\n                this._weightedQueues[weight - 1] = [];\n            this._weightedQueues[weight - 1].push({ resolve, reject });\n            this._dispatch();\n        });\n    }\n    runExclusive(callback, weight = 1) {\n        return __awaiter$2(this, void 0, void 0, function* () {\n            const [value, release] = yield this.acquire(weight);\n            try {\n                return yield callback(value);\n            }\n            finally {\n                release();\n            }\n        });\n    }\n    waitForUnlock(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        return new Promise((resolve) => {\n            if (!this._weightedWaiters[weight - 1])\n                this._weightedWaiters[weight - 1] = [];\n            this._weightedWaiters[weight - 1].push(resolve);\n            this._dispatch();\n        });\n    }\n    isLocked() {\n        return this._value <= 0;\n    }\n    getValue() {\n        return this._value;\n    }\n    setValue(value) {\n        this._value = value;\n        this._dispatch();\n    }\n    release(weight = 1) {\n        if (weight <= 0)\n            throw new Error(`invalid weight ${weight}: must be positive`);\n        this._value += weight;\n        this._dispatch();\n    }\n    cancel() {\n        this._weightedQueues.forEach((queue) => queue.forEach((entry) => entry.reject(this._cancelError)));\n        this._weightedQueues = [];\n    }\n    _dispatch() {\n        var _a;\n        for (let weight = this._value; weight > 0; weight--) {\n            const queueEntry = (_a = this._weightedQueues[weight - 1]) === null || _a === void 0 ? void 0 : _a.shift();\n            if (!queueEntry)\n                continue;\n            const previousValue = this._value;\n            const previousWeight = weight;\n            this._value -= weight;\n            weight = this._value + 1;\n            queueEntry.resolve([previousValue, this._newReleaser(previousWeight)]);\n        }\n        this._drainUnlockWaiters();\n    }\n    _newReleaser(weight) {\n        let called = false;\n        return () => {\n            if (called)\n                return;\n            called = true;\n            this.release(weight);\n        };\n    }\n    _drainUnlockWaiters() {\n        for (let weight = this._value; weight > 0; weight--) {\n            if (!this._weightedWaiters[weight - 1])\n                continue;\n            this._weightedWaiters[weight - 1].forEach((waiter) => waiter());\n            this._weightedWaiters[weight - 1] = [];\n        }\n    }\n}\n\nvar __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nclass Mutex {\n    constructor(cancelError) {\n        this._semaphore = new Semaphore(1, cancelError);\n    }\n    acquire() {\n        return __awaiter$1(this, void 0, void 0, function* () {\n            const [, releaser] = yield this._semaphore.acquire();\n            return releaser;\n        });\n    }\n    runExclusive(callback) {\n        return this._semaphore.runExclusive(() => callback());\n    }\n    isLocked() {\n        return this._semaphore.isLocked();\n    }\n    waitForUnlock() {\n        return this._semaphore.waitForUnlock();\n    }\n    release() {\n        if (this._semaphore.isLocked())\n            this._semaphore.release();\n    }\n    cancel() {\n        return this._semaphore.cancel();\n    }\n}\n\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction withTimeout(sync, timeout, timeoutError = E_TIMEOUT) {\n    return {\n        acquire: (weight) => {\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                let isTimeout = false;\n                const handle = setTimeout(() => {\n                    isTimeout = true;\n                    reject(timeoutError);\n                }, timeout);\n                try {\n                    const ticket = yield sync.acquire(weight);\n                    if (isTimeout) {\n                        const release = Array.isArray(ticket) ? ticket[1] : ticket;\n                        release();\n                    }\n                    else {\n                        clearTimeout(handle);\n                        resolve(ticket);\n                    }\n                }\n                catch (e) {\n                    if (!isTimeout) {\n                        clearTimeout(handle);\n                        reject(e);\n                    }\n                }\n            }));\n        },\n        runExclusive(callback, weight) {\n            return __awaiter(this, void 0, void 0, function* () {\n                let release = () => undefined;\n                try {\n                    const ticket = yield this.acquire(weight);\n                    if (Array.isArray(ticket)) {\n                        release = ticket[1];\n                        return yield callback(ticket[0]);\n                    }\n                    else {\n                        release = ticket;\n                        return yield callback();\n                    }\n                }\n                finally {\n                    release();\n                }\n            });\n        },\n        release(weight) {\n            sync.release(weight);\n        },\n        cancel() {\n            return sync.cancel();\n        },\n        waitForUnlock: (weight) => {\n            if (weight !== undefined && weight <= 0) {\n                throw new Error(`invalid weight ${weight}: must be positive`);\n            }\n            return new Promise((resolve, reject) => {\n                const handle = setTimeout(() => reject(timeoutError), timeout);\n                sync.waitForUnlock(weight).then(() => {\n                    clearTimeout(handle);\n                    resolve();\n                });\n            });\n        },\n        isLocked: () => sync.isLocked(),\n        getValue: () => sync.getValue(),\n        setValue: (value) => sync.setValue(value),\n    };\n}\n\n// eslint-disable-next-lisne @typescript-eslint/explicit-module-boundary-types\nfunction tryAcquire(sync, alreadyAcquiredError = E_ALREADY_LOCKED) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return withTimeout(sync, 0, alreadyAcquiredError);\n}\n\nexport { E_ALREADY_LOCKED, E_CANCELED, E_TIMEOUT, Mutex, Semaphore, tryAcquire, withTimeout };\n","/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst proxyMarker = Symbol(\"Comlink.proxy\");\nconst createEndpoint = Symbol(\"Comlink.endpoint\");\nconst releaseProxy = Symbol(\"Comlink.releaseProxy\");\nconst finalizer = Symbol(\"Comlink.finalizer\");\nconst throwMarker = Symbol(\"Comlink.thrown\");\nconst isObject = (val) => (typeof val === \"object\" && val !== null) || typeof val === \"function\";\n/**\n * Internal transfer handle to handle objects marked to proxy.\n */\nconst proxyTransferHandler = {\n    canHandle: (val) => isObject(val) && val[proxyMarker],\n    serialize(obj) {\n        const { port1, port2 } = new MessageChannel();\n        expose(obj, port1);\n        return [port2, [port2]];\n    },\n    deserialize(port) {\n        port.start();\n        return wrap(port);\n    },\n};\n/**\n * Internal transfer handler to handle thrown exceptions.\n */\nconst throwTransferHandler = {\n    canHandle: (value) => isObject(value) && throwMarker in value,\n    serialize({ value }) {\n        let serialized;\n        if (value instanceof Error) {\n            serialized = {\n                isError: true,\n                value: {\n                    message: value.message,\n                    name: value.name,\n                    stack: value.stack,\n                },\n            };\n        }\n        else {\n            serialized = { isError: false, value };\n        }\n        return [serialized, []];\n    },\n    deserialize(serialized) {\n        if (serialized.isError) {\n            throw Object.assign(new Error(serialized.value.message), serialized.value);\n        }\n        throw serialized.value;\n    },\n};\n/**\n * Allows customizing the serialization of certain values.\n */\nconst transferHandlers = new Map([\n    [\"proxy\", proxyTransferHandler],\n    [\"throw\", throwTransferHandler],\n]);\nfunction isAllowedOrigin(allowedOrigins, origin) {\n    for (const allowedOrigin of allowedOrigins) {\n        if (origin === allowedOrigin || allowedOrigin === \"*\") {\n            return true;\n        }\n        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction expose(obj, ep = globalThis, allowedOrigins = [\"*\"]) {\n    ep.addEventListener(\"message\", function callback(ev) {\n        if (!ev || !ev.data) {\n            return;\n        }\n        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {\n            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);\n            return;\n        }\n        const { id, type, path } = Object.assign({ path: [] }, ev.data);\n        const argumentList = (ev.data.argumentList || []).map(fromWireValue);\n        let returnValue;\n        try {\n            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);\n            const rawValue = path.reduce((obj, prop) => obj[prop], obj);\n            switch (type) {\n                case \"GET\" /* MessageType.GET */:\n                    {\n                        returnValue = rawValue;\n                    }\n                    break;\n                case \"SET\" /* MessageType.SET */:\n                    {\n                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);\n                        returnValue = true;\n                    }\n                    break;\n                case \"APPLY\" /* MessageType.APPLY */:\n                    {\n                        returnValue = rawValue.apply(parent, argumentList);\n                    }\n                    break;\n                case \"CONSTRUCT\" /* MessageType.CONSTRUCT */:\n                    {\n                        const value = new rawValue(...argumentList);\n                        returnValue = proxy(value);\n                    }\n                    break;\n                case \"ENDPOINT\" /* MessageType.ENDPOINT */:\n                    {\n                        const { port1, port2 } = new MessageChannel();\n                        expose(obj, port2);\n                        returnValue = transfer(port1, [port1]);\n                    }\n                    break;\n                case \"RELEASE\" /* MessageType.RELEASE */:\n                    {\n                        returnValue = undefined;\n                    }\n                    break;\n                default:\n                    return;\n            }\n        }\n        catch (value) {\n            returnValue = { value, [throwMarker]: 0 };\n        }\n        Promise.resolve(returnValue)\n            .catch((value) => {\n            return { value, [throwMarker]: 0 };\n        })\n            .then((returnValue) => {\n            const [wireValue, transferables] = toWireValue(returnValue);\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n            if (type === \"RELEASE\" /* MessageType.RELEASE */) {\n                // detach and deactive after sending release response above.\n                ep.removeEventListener(\"message\", callback);\n                closeEndPoint(ep);\n                if (finalizer in obj && typeof obj[finalizer] === \"function\") {\n                    obj[finalizer]();\n                }\n            }\n        })\n            .catch((error) => {\n            // Send Serialization Error To Caller\n            const [wireValue, transferables] = toWireValue({\n                value: new TypeError(\"Unserializable return value\"),\n                [throwMarker]: 0,\n            });\n            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);\n        });\n    });\n    if (ep.start) {\n        ep.start();\n    }\n}\nfunction isMessagePort(endpoint) {\n    return endpoint.constructor.name === \"MessagePort\";\n}\nfunction closeEndPoint(endpoint) {\n    if (isMessagePort(endpoint))\n        endpoint.close();\n}\nfunction wrap(ep, target) {\n    return createProxy(ep, [], target);\n}\nfunction throwIfProxyReleased(isReleased) {\n    if (isReleased) {\n        throw new Error(\"Proxy has been released and is not useable\");\n    }\n}\nfunction releaseEndpoint(ep) {\n    return requestResponseMessage(ep, {\n        type: \"RELEASE\" /* MessageType.RELEASE */,\n    }).then(() => {\n        closeEndPoint(ep);\n    });\n}\nconst proxyCounter = new WeakMap();\nconst proxyFinalizers = \"FinalizationRegistry\" in globalThis &&\n    new FinalizationRegistry((ep) => {\n        const newCount = (proxyCounter.get(ep) || 0) - 1;\n        proxyCounter.set(ep, newCount);\n        if (newCount === 0) {\n            releaseEndpoint(ep);\n        }\n    });\nfunction registerProxy(proxy, ep) {\n    const newCount = (proxyCounter.get(ep) || 0) + 1;\n    proxyCounter.set(ep, newCount);\n    if (proxyFinalizers) {\n        proxyFinalizers.register(proxy, ep, proxy);\n    }\n}\nfunction unregisterProxy(proxy) {\n    if (proxyFinalizers) {\n        proxyFinalizers.unregister(proxy);\n    }\n}\nfunction createProxy(ep, path = [], target = function () { }) {\n    let isProxyReleased = false;\n    const proxy = new Proxy(target, {\n        get(_target, prop) {\n            throwIfProxyReleased(isProxyReleased);\n            if (prop === releaseProxy) {\n                return () => {\n                    unregisterProxy(proxy);\n                    releaseEndpoint(ep);\n                    isProxyReleased = true;\n                };\n            }\n            if (prop === \"then\") {\n                if (path.length === 0) {\n                    return { then: () => proxy };\n                }\n                const r = requestResponseMessage(ep, {\n                    type: \"GET\" /* MessageType.GET */,\n                    path: path.map((p) => p.toString()),\n                }).then(fromWireValue);\n                return r.then.bind(r);\n            }\n            return createProxy(ep, [...path, prop]);\n        },\n        set(_target, prop, rawValue) {\n            throwIfProxyReleased(isProxyReleased);\n            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a\n            // boolean. To show good will, we return true asynchronously ¯\\_(ツ)_/¯\n            const [value, transferables] = toWireValue(rawValue);\n            return requestResponseMessage(ep, {\n                type: \"SET\" /* MessageType.SET */,\n                path: [...path, prop].map((p) => p.toString()),\n                value,\n            }, transferables).then(fromWireValue);\n        },\n        apply(_target, _thisArg, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const last = path[path.length - 1];\n            if (last === createEndpoint) {\n                return requestResponseMessage(ep, {\n                    type: \"ENDPOINT\" /* MessageType.ENDPOINT */,\n                }).then(fromWireValue);\n            }\n            // We just pretend that `bind()` didn’t happen.\n            if (last === \"bind\") {\n                return createProxy(ep, path.slice(0, -1));\n            }\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"APPLY\" /* MessageType.APPLY */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n        construct(_target, rawArgumentList) {\n            throwIfProxyReleased(isProxyReleased);\n            const [argumentList, transferables] = processArguments(rawArgumentList);\n            return requestResponseMessage(ep, {\n                type: \"CONSTRUCT\" /* MessageType.CONSTRUCT */,\n                path: path.map((p) => p.toString()),\n                argumentList,\n            }, transferables).then(fromWireValue);\n        },\n    });\n    registerProxy(proxy, ep);\n    return proxy;\n}\nfunction myFlat(arr) {\n    return Array.prototype.concat.apply([], arr);\n}\nfunction processArguments(argumentList) {\n    const processed = argumentList.map(toWireValue);\n    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];\n}\nconst transferCache = new WeakMap();\nfunction transfer(obj, transfers) {\n    transferCache.set(obj, transfers);\n    return obj;\n}\nfunction proxy(obj) {\n    return Object.assign(obj, { [proxyMarker]: true });\n}\nfunction windowEndpoint(w, context = globalThis, targetOrigin = \"*\") {\n    return {\n        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),\n        addEventListener: context.addEventListener.bind(context),\n        removeEventListener: context.removeEventListener.bind(context),\n    };\n}\nfunction toWireValue(value) {\n    for (const [name, handler] of transferHandlers) {\n        if (handler.canHandle(value)) {\n            const [serializedValue, transferables] = handler.serialize(value);\n            return [\n                {\n                    type: \"HANDLER\" /* WireValueType.HANDLER */,\n                    name,\n                    value: serializedValue,\n                },\n                transferables,\n            ];\n        }\n    }\n    return [\n        {\n            type: \"RAW\" /* WireValueType.RAW */,\n            value,\n        },\n        transferCache.get(value) || [],\n    ];\n}\nfunction fromWireValue(value) {\n    switch (value.type) {\n        case \"HANDLER\" /* WireValueType.HANDLER */:\n            return transferHandlers.get(value.name).deserialize(value.value);\n        case \"RAW\" /* WireValueType.RAW */:\n            return value.value;\n    }\n}\nfunction requestResponseMessage(ep, msg, transfers) {\n    return new Promise((resolve) => {\n        const id = generateUUID();\n        ep.addEventListener(\"message\", function l(ev) {\n            if (!ev.data || !ev.data.id || ev.data.id !== id) {\n                return;\n            }\n            ep.removeEventListener(\"message\", l);\n            resolve(ev.data);\n        });\n        if (ep.start) {\n            ep.start();\n        }\n        ep.postMessage(Object.assign({ id }, msg), transfers);\n    });\n}\nfunction generateUUID() {\n    return new Array(4)\n        .fill(0)\n        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))\n        .join(\"-\");\n}\n\nexport { createEndpoint, expose, finalizer, proxy, proxyMarker, releaseProxy, transfer, transferHandlers, windowEndpoint, wrap };\n//# sourceMappingURL=comlink.mjs.map\n","// Copyright 2021 Roy T. Hashimoto. All Rights Reserved.\n\nimport * as SQLite from './sqlite-constants.js';\nexport * from './sqlite-constants.js';\n\n/**\n * Need to have a serializer for bigint\n * https://github.com/GoogleChromeLabs/jsbi/issues/30\n */\nif (typeof BigInt.prototype['toJSON'] == 'undefined') {\n  BigInt.prototype['toJSON'] = function() {\n    return this.toString();\n  };\n}\n\nconst MAX_INT64 = 0x7fffffffffffffffn;\nconst MIN_INT64 = -0x8000000000000000n;\n\nconst AsyncFunction = Object.getPrototypeOf(async function(){}).constructor;\n\nexport class SQLiteError extends Error {\n  constructor(message, code) {\n    super(message);\n    this.code = code;\n  }\n}\n\nconst async = true;\n\n\n/**\n * Builds a Javascript API from the Emscripten module. This API is still\n * low-level and closely corresponds to the C API exported by the module,\n * but differs in some specifics like throwing exceptions on errors.\n * @param {*} Module SQLite Emscripten module\n * @returns {SQLiteAPI}\n */\nexport function Factory(Module) {\n  /** @type {SQLiteAPI} */ const sqlite3 = {};\n\n  Module.retryOps = [];\n  const sqliteFreeAddress = Module._getSqliteFree();\n\n  // Allocate some space for 32-bit returned values.\n  const tmp = Module._malloc(8);\n  const tmpPtr = [tmp, tmp + 4];\n\n  // Convert a JS string to a C string. sqlite3_malloc is used to allocate\n  // memory (use sqlite3_free to deallocate).\n  function createUTF8(s) {\n    if (typeof s !== 'string') return 0;\n    const utf8 = new TextEncoder().encode(s);\n    const zts = Module._sqlite3_malloc(utf8.byteLength + 1);\n    Module.HEAPU8.set(utf8, zts);\n    Module.HEAPU8[zts + utf8.byteLength] = 0;\n    return zts;\n  }\n\n  /**\n   * Concatenate 32-bit numbers into a 64-bit (signed) BigInt.\n   * @param {number} lo32\n   * @param {number} hi32\n   * @returns {bigint}\n   */\n  function cvt32x2ToBigInt(lo32, hi32) {\n    return (BigInt(hi32) << 32n) | (BigInt(lo32) & 0xffffffffn);\n  }\n\n  // /**\n  //  * Setup table change update callback\n  //  */\n  // var onTableChangedFunctionPointer = Module.addFunction(onTableUpdate);\n  // var passFnPointer = Module.cwrap('passFnPointer', 'undefined', ['number']);\n  // passFnPointer(onTableChangedFunctionPointer);\n  /**\n   * Concatenate 32-bit numbers and return as number or BigInt, depending\n   * on the value.\n   * @param {number} lo32\n   * @param {number} hi32\n   * @returns {number|bigint}\n   */\n  const cvt32x2AsSafe = (function() {\n    const hiMax = BigInt(Number.MAX_SAFE_INTEGER) >> 32n;\n    const hiMin = BigInt(Number.MIN_SAFE_INTEGER) >> 32n;\n\n    return function(lo32, hi32) {\n      if (hi32 > hiMax || hi32 < hiMin) {\n        // Can't be expressed as a Number so use BigInt.\n        return cvt32x2ToBigInt(lo32, hi32);\n      } else {\n        // Combine the upper and lower 32-bit numbers. The complication is\n        // that lo32 is a signed integer which makes manipulating its bits\n        // a little tricky - the sign bit gets handled separately.\n        return hi32 * 0x100000000 + (lo32 & 0x7fffffff) - (lo32 & 0x80000000);\n      }\n    };\n  })();\n\n  const databases = new Set();\n  function verifyDatabase(db) {\n    if (!databases.has(db)) {\n      throw new SQLiteError('not a database', SQLite.SQLITE_MISUSE);\n    }\n  }\n\n  const mapStmtToDB = new Map();\n  function verifyStatement(stmt) {\n    if (!mapStmtToDB.has(stmt)) {\n      throw new SQLiteError('not a statement', SQLite.SQLITE_MISUSE);\n    }\n  }\n\n  sqlite3.bind_collection = function(stmt, bindings) {\n    verifyStatement(stmt);\n    const isArray = Array.isArray(bindings);\n    const nBindings = sqlite3.bind_parameter_count(stmt);\n    for (let i = 1; i <= nBindings; ++i) {\n      const key = isArray ? i - 1 : sqlite3.bind_parameter_name(stmt, i);\n      const value = bindings[key];\n      if (value !== undefined) {\n        sqlite3.bind(stmt, i, value);\n      }\n    }\n    return SQLite.SQLITE_OK;\n  };\n\n  sqlite3.bind = function(stmt, i, value) {\n    verifyStatement(stmt);\n    switch (typeof value) {\n      case 'number':\n        if (value === (value | 0)) {\n          return sqlite3.bind_int(stmt, i, value);\n        } else {\n          return sqlite3.bind_double(stmt, i, value);\n        }\n      case 'string':\n        return sqlite3.bind_text(stmt, i, value);\n      default:\n        if (value instanceof Uint8Array || Array.isArray(value)) {\n          return sqlite3.bind_blob(stmt, i, value);\n        } else if (value === null) {\n          return sqlite3.bind_null(stmt, i);\n        } else if (typeof value === 'bigint') {\n          return sqlite3.bind_int64(stmt, i, value);\n        } else if (value === undefined) {\n          // Existing binding (or NULL) will be used.\n          return SQLite.SQLITE_NOTICE;\n        } else {\n          console.warn('unknown binding converted to null', value);\n          return sqlite3.bind_null(stmt, i);\n        }\n    }\n  };\n\n  sqlite3.bind_blob = (function() {\n    const fname = 'sqlite3_bind_blob';\n    const f = Module.cwrap(fname, ...decl('nnnnn:n'));\n    return function(stmt, i, value) {\n      verifyStatement(stmt);\n      // @ts-ignore\n      const byteLength = value.byteLength ?? value.length;\n      const ptr = Module._sqlite3_malloc(byteLength);\n      Module.HEAPU8.subarray(ptr).set(value);\n      const result = f(stmt, i, ptr, byteLength, sqliteFreeAddress);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.bind_parameter_count = (function() {\n    const fname = 'sqlite3_bind_parameter_count';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(stmt) {\n      verifyStatement(stmt);\n      const result = f(stmt);\n      return result;\n    };\n  })();\n\n  sqlite3.bind_double = (function() {\n    const fname = 'sqlite3_bind_double';\n    const f = Module.cwrap(fname, ...decl('nnn:n'));\n    return function(stmt, i, value) {\n      verifyStatement(stmt);\n      const result = f(stmt, i, value);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.bind_int = (function() {\n    const fname = 'sqlite3_bind_int';\n    const f = Module.cwrap(fname, ...decl('nnn:n'));\n    return function(stmt, i, value) {\n      verifyStatement(stmt);\n      if (value > 0x7fffffff || value < -0x80000000) return SQLite.SQLITE_RANGE;\n\n      const result = f(stmt, i, value);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.bind_int64 = (function() {\n    const fname = 'sqlite3_bind_int64';\n    const f = Module.cwrap(fname, ...decl('nnnn:n'));\n    return function(stmt, i, value) {\n      verifyStatement(stmt);\n      if (value > MAX_INT64 || value < MIN_INT64) return SQLite.SQLITE_RANGE;\n\n      const lo32 = value & 0xffffffffn;\n      const hi32 = value >> 32n;\n      const result = f(stmt, i, Number(lo32), Number(hi32));\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.bind_null = (function() {\n    const fname = 'sqlite3_bind_null';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, i) {\n      verifyStatement(stmt);\n      const result = f(stmt, i);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.bind_parameter_name = (function() {\n    const fname = 'sqlite3_bind_parameter_name';\n    const f = Module.cwrap(fname, ...decl('n:s'));\n    return function(stmt, i) {\n      verifyStatement(stmt);\n      const result = f(stmt, i);\n      return result;\n    };\n  })();\n\n  sqlite3.bind_text = (function() {\n    const fname = 'sqlite3_bind_text';\n    const f = Module.cwrap(fname, ...decl('nnnnn:n'));\n    return function(stmt, i, value) {\n      verifyStatement(stmt);\n      const ptr = createUTF8(value);\n      const result = f(stmt, i, ptr, -1, sqliteFreeAddress);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.changes = (function() {\n    const fname = 'sqlite3_changes';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(db) {\n      verifyDatabase(db);\n      const result = f(db);\n      return result;\n    };\n  })();\n\n  sqlite3.clear_bindings = (function() {\n    const fname = 'sqlite3_clear_bindings';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(stmt) {\n      verifyStatement(stmt);\n      const result = f(stmt);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.last_insert_id = (function() {\n    const fname = 'sqlite3_last_insert_rowid';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(db) {\n      verifyDatabase(db);\n      const result = f(db);\n      // trace(fname, result);\n      return result;\n    };\n  })();\n  \n  sqlite3.close = (function() {\n    const fname = 'sqlite3_close';\n    const f = Module.cwrap(fname, ...decl('n:n'), { async });\n    return async function(db) {\n      verifyDatabase(db);\n      const result = await f(db);\n      databases.delete(db);\n      return check(fname, result, db);\n    };\n  })();\n\n  sqlite3.column = function(stmt, iCol) {\n    verifyStatement(stmt);\n    const type = sqlite3.column_type(stmt, iCol);\n    switch (type) {\n      case SQLite.SQLITE_BLOB:\n        return sqlite3.column_blob(stmt, iCol);\n      case SQLite.SQLITE_FLOAT:\n        return sqlite3.column_double(stmt, iCol);\n      case SQLite.SQLITE_INTEGER:\n        const lo32 = sqlite3.column_int(stmt, iCol);\n        const hi32 = Module.getTempRet0();\n        return cvt32x2AsSafe(lo32, hi32);\n      case SQLite.SQLITE_NULL:\n        return null;\n      case SQLite.SQLITE_TEXT:\n        return sqlite3.column_text(stmt, iCol);\n      default:\n        throw new SQLiteError('unknown type', type);\n    }\n  };\n\n  sqlite3.column_blob = (function() {\n    const fname = 'sqlite3_column_blob';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const nBytes = sqlite3.column_bytes(stmt, iCol);\n      const address = f(stmt, iCol);\n      const result = Module.HEAPU8.subarray(address, address + nBytes);\n      return result;\n    };\n  })();\n\n  sqlite3.column_bytes = (function() {\n    const fname = 'sqlite3_column_bytes';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      return result;\n    };\n  })();\n\n  sqlite3.column_count = (function() {\n    const fname = 'sqlite3_column_count';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(stmt) {\n      verifyStatement(stmt);\n      const result = f(stmt);\n      return result;\n    };\n  })();\n\n  sqlite3.column_double = (function() {\n    const fname = 'sqlite3_column_double';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      return result;\n    };\n  })();\n\n  sqlite3.column_int = (function() {\n    // Retrieve int64 but use only the lower 32 bits. The upper 32-bits are\n    // accessible with Module.getTempRet0().\n    const fname = 'sqlite3_column_int64';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      return result;\n    };\n  })();\n\n  sqlite3.column_int64 = (function() {\n    const fname = 'sqlite3_column_int64';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const lo32 = f(stmt, iCol);\n      const hi32 = Module.getTempRet0();\n      const result = cvt32x2ToBigInt(lo32, hi32);\n      return result;\n    };\n  })();\n\n  sqlite3.column_name = (function() {\n    const fname = 'sqlite3_column_name';\n    const f = Module.cwrap(fname, ...decl('nn:s'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      return result;\n    };\n  })();\n\n  sqlite3.column_names = function(stmt) {\n    const columns = [];\n    const nColumns = sqlite3.column_count(stmt);\n    for (let i = 0; i < nColumns; ++i) {\n      columns.push(sqlite3.column_name(stmt, i));\n    }\n    return columns;\n  };\n\n  sqlite3.column_text = (function() {\n    const fname = 'sqlite3_column_text';\n    const f = Module.cwrap(fname, ...decl('nn:s'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      return result;\n    };\n  })();\n\n  sqlite3.column_type = (function() {\n    const fname = 'sqlite3_column_type';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(stmt, iCol) {\n      verifyStatement(stmt);\n      const result = f(stmt, iCol);\n      return result;\n    };\n  })();\n\n  sqlite3.create_function = function(db, zFunctionName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {\n    verifyDatabase(db);\n    \n    // Convert SQLite callback arguments to JavaScript-friendly arguments.\n    function adapt(f) {\n      return f instanceof AsyncFunction ?\n        (async (ctx, n, values) => f(ctx, Module.HEAP32.subarray(values / 4, values / 4 + n))) :\n        ((ctx, n, values) => f(ctx, Module.HEAP32.subarray(values / 4, values / 4 + n)));\n    }\n\n    const result = Module.create_function(\n      db,\n      zFunctionName,\n      nArg,\n      eTextRep,\n      pApp,\n      xFunc && adapt(xFunc),\n      xStep && adapt(xStep),\n      xFinal);\n    return check('sqlite3_create_function', result, db);\n  };\n\n  sqlite3.data_count = (function() {\n    const fname = 'sqlite3_data_count';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(stmt) {\n      verifyStatement(stmt);\n      const result = f(stmt);\n      return result;\n    };\n  })();\n\n  sqlite3.exec = async function(db, sql, callback) {\n    for await (const stmt of sqlite3.statements(db, sql)) {\n      let columns;\n      while ((await sqlite3.step(stmt)) === SQLite.SQLITE_ROW) {\n        if (callback) {\n          columns = columns ?? sqlite3.column_names(stmt);\n          const row = sqlite3.row(stmt);\n          await callback(row, columns);\n        }\n      }\n    }\n    return SQLite.SQLITE_OK;\n  };\n\n  sqlite3.finalize = (function() {\n    const fname = 'sqlite3_finalize';\n    const f = Module.cwrap(fname, ...decl('n:n'), { async });\n    return async function(stmt) {\n      const result = await f(stmt);\n      mapStmtToDB.delete(stmt)\n\n      // Don't throw on error here. Typically the error has already been\n      // thrown and finalize() is part of the cleanup.\n      return result;\n    };\n  })();\n\n  sqlite3.get_autocommit = (function() {\n    const fname = 'sqlite3_get_autocommit';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(db) {\n      const result = f(db);\n      return result;\n    };\n  })();\n\n  sqlite3.libversion = (function() {\n    const fname = 'sqlite3_libversion';\n    const f = Module.cwrap(fname, ...decl(':s'));\n    return function() {\n      const result = f();\n      return result;\n    };\n  })();\n\n  sqlite3.libversion_number = (function() {\n    const fname = 'sqlite3_libversion_number';\n    const f = Module.cwrap(fname, ...decl(':n'));\n    return function() {\n      const result = f();\n      return result;\n    };\n  })();\n\n  sqlite3.limit = (function() {\n    const fname = 'sqlite3_limit';\n    const f = Module.cwrap(fname, ...decl('nnn:n'));\n    return function(db, id, newVal) {\n      const result = f(db, id, newVal);\n      return result;\n    };\n  })();\n\n  sqlite3.open_v2 = (function() {\n    const fname = 'sqlite3_open_v2';\n    const f = Module.cwrap(fname, ...decl('snnn:n'), { async });\n    return async function(zFilename, flags, zVfs) {\n      flags = flags || SQLite.SQLITE_OPEN_CREATE | SQLite.SQLITE_OPEN_READWRITE;\n      zVfs = createUTF8(zVfs);\n      try {\n        // Allow retry operations.\n        const rc = await retry(() => f(zFilename, tmpPtr[0], flags, zVfs));\n\n        const db = Module.getValue(tmpPtr[0], '*');\n        databases.add(db);\n\n        Module.ccall('RegisterExtensionFunctions', 'number', ['number'], [db]);\n        check(fname, rc);\n        return db;\n      } finally {\n        Module._sqlite3_free(zVfs);\n      }\n    };\n  })();\n\n  sqlite3.progress_handler = function(db, nProgressOps, handler, userData) {\n    verifyDatabase(db);\n    Module.progress_handler(db, nProgressOps, handler, userData);\n  };;\n\n  sqlite3.reset = (function() {\n    const fname = 'sqlite3_reset';\n    const f = Module.cwrap(fname, ...decl('n:n'), { async });\n    return async function(stmt) {\n      verifyStatement(stmt);\n      const result = await f(stmt);\n      return check(fname, result, mapStmtToDB.get(stmt));\n    };\n  })();\n\n  sqlite3.result = function(context, value) {\n    switch (typeof value) {\n      case 'number':\n        if (value === (value | 0)) {\n          sqlite3.result_int(context, value);\n        } else {\n          sqlite3.result_double(context, value);\n        }\n        break;\n      case 'string':\n        sqlite3.result_text(context, value);\n        break;\n      default:\n        if (value instanceof Uint8Array || Array.isArray(value)) {\n          sqlite3.result_blob(context, value);\n        } else if (value === null) {\n          sqlite3.result_null(context);\n        } else if (typeof value === 'bigint') {\n          return sqlite3.result_int64(context, value);\n        } else {\n          console.warn('unknown result converted to null', value);\n          sqlite3.result_null(context);\n        }\n        break;\n    }\n  };\n\n  sqlite3.result_blob = (function() {\n    const fname = 'sqlite3_result_blob';\n    const f = Module.cwrap(fname, ...decl('nnnn:n'));\n    return function(context, value) {\n      // @ts-ignore\n      const byteLength = value.byteLength ?? value.length;\n      const ptr = Module._sqlite3_malloc(byteLength);\n      Module.HEAPU8.subarray(ptr).set(value);\n      f(context, ptr, byteLength, sqliteFreeAddress); // void return\n    };\n  })();\n\n  sqlite3.result_double = (function() {\n    const fname = 'sqlite3_result_double';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(context, value) {\n      f(context, value); // void return\n    };\n  })();\n\n  sqlite3.result_int = (function() {\n    const fname = 'sqlite3_result_int';\n    const f = Module.cwrap(fname, ...decl('nn:n'));\n    return function(context, value) {\n      f(context, value); // void return\n    };\n  })();\n\n  sqlite3.result_int64 = (function() {\n    const fname = 'sqlite3_result_int64';\n    const f = Module.cwrap(fname, ...decl('nnn:n'));\n    return function(context, value) {\n      if (value > MAX_INT64 || value < MIN_INT64) return SQLite.SQLITE_RANGE;\n\n      const lo32 = value & 0xffffffffn;\n      const hi32 = value >> 32n;\n      f(context, Number(lo32), Number(hi32)); // void return\n    };\n  })();\n\n  sqlite3.result_null = (function() {\n    const fname = 'sqlite3_result_null';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(context) {\n      f(context); // void return\n    };\n  })();\n\n  sqlite3.result_text = (function() {\n    const fname = 'sqlite3_result_text';\n    const f = Module.cwrap(fname, ...decl('nnnn:n'));\n    return function(context, value) {\n      const ptr = createUTF8(value);\n      f(context, ptr, -1, sqliteFreeAddress); // void return\n    };\n  })();\n\n  sqlite3.row = function(stmt) {\n    const row = [];\n    const nColumns = sqlite3.data_count(stmt);\n    for (let i = 0; i < nColumns; ++i) {\n      const value = sqlite3.column(stmt, i);\n\n      // Copy blob if aliasing volatile WebAssembly memory. This avoids an\n      // unnecessary copy if users monkey patch column_blob to copy.\n      // @ts-ignore\n      row.push(value?.buffer === Module.HEAPU8.buffer ? value.slice() : value);\n    }\n    return row;\n  };\n\n  sqlite3.set_authorizer = function(db, xAuth, pApp) {\n    verifyDatabase(db);\n\n    // Convert SQLite callback arguments to JavaScript-friendly arguments.\n    function cvtArgs(_, iAction, p3, p4, p5, p6) {\n      return [\n        _,\n        iAction,\n        Module.UTF8ToString(p3),\n        Module.UTF8ToString(p4),\n        Module.UTF8ToString(p5),\n        Module.UTF8ToString(p6)\n      ];\n    };\n    function adapt(f) {\n      return f instanceof AsyncFunction ?\n        (async (_, iAction, p3, p4, p5, p6) => f(...cvtArgs(_, iAction, p3, p4, p5, p6))) :\n        ((_, iAction, p3, p4, p5, p6) => f(...cvtArgs(_, iAction, p3, p4, p5, p6)));\n    }\n\n    const result = Module.set_authorizer(db, adapt(xAuth), pApp);\n    return check('sqlite3_set_authorizer', result, db);\n  };\n\n  sqlite3.sql = (function() {\n    const fname = 'sqlite3_sql';\n    const f = Module.cwrap(fname, ...decl('n:s'));\n    return function(stmt) {\n      verifyStatement(stmt);\n      const result = f(stmt);\n      return result;\n    };\n  })();\n\n  sqlite3.statements = function(db, sql, options = {}) {\n    const prepare = Module.cwrap(\n      'sqlite3_prepare_v3',\n      'number',\n      ['number', 'number', 'number', 'number', 'number', 'number'],\n      { async: true });\n\n    return (async function*() {\n      const onFinally = [];\n      try {\n        // Encode SQL string to UTF-8.\n        const utf8 = new TextEncoder().encode(sql);\n\n        // Copy encoded string to WebAssembly memory. The SQLite docs say\n        // zero-termination is a minor optimization so add room for that.\n        // Also add space for the statement handle and SQL tail pointer.\n        const allocSize = utf8.byteLength - (utf8.byteLength % 4) + 12;\n        const pzHead = Module._sqlite3_malloc(allocSize);\n        const pzEnd = pzHead + utf8.byteLength + 1;\n        onFinally.push(() => Module._sqlite3_free(pzHead));\n        Module.HEAPU8.set(utf8, pzHead);\n        Module.HEAPU8[pzEnd - 1] = 0;\n  \n        // Use extra space for the statement handle and SQL tail pointer.\n        const pStmt = pzHead + allocSize - 8;\n        const pzTail = pzHead + allocSize - 4;\n\n        // Ensure that statement handles are not leaked.\n        let stmt;\n        function maybeFinalize() {\n          if (stmt && !options.unscoped) {\n            sqlite3.finalize(stmt);\n          }\n          stmt = 0;\n        }\n        onFinally.push(maybeFinalize);\n        \n        // Loop over statements.\n        Module.setValue(pzTail, pzHead, '*');\n        do {\n          // Reclaim resources for the previous iteration.\n          maybeFinalize();\n\n          // Call sqlite3_prepare_v3() for the next statement.\n          // Allow retry operations.\n          const zTail = Module.getValue(pzTail, '*');\n          const rc = await retry(() => {\n            return prepare(\n              db,\n              zTail,\n              pzEnd - pzTail,\n              options.flags || 0,\n              pStmt,\n              pzTail);\n          });\n\n          if (rc !== SQLite.SQLITE_OK) {\n            check('sqlite3_prepare_v3', rc, db);\n          }\n          \n          stmt = Module.getValue(pStmt, '*');\n          if (stmt) {\n            mapStmtToDB.set(stmt, db);\n            yield stmt;\n          }\n        } while (stmt);\n      } finally {\n        while (onFinally.length) {\n          onFinally.pop()();\n        }\n      }\n    })();\n  };\n\n  sqlite3.step = (function() {\n    const fname = 'sqlite3_step';\n    const f = Module.cwrap(fname, ...decl('n:n'), { async });\n    return async function(stmt) {\n      verifyStatement(stmt);\n\n      // Allow retry operations.\n      const rc = await retry(() => f(stmt));\n\n      return check(fname, rc, mapStmtToDB.get(stmt), [SQLite.SQLITE_ROW, SQLite.SQLITE_DONE]);\n    };\n  })();\n\n  sqlite3.commit_hook = function(db, xCommitHook) {\n    verifyDatabase(db);\n    Module.commit_hook(db, xCommitHook);\n  };\n\n  sqlite3.update_hook = function(db, xUpdateHook) {\n    verifyDatabase(db);\n\n    // Convert SQLite callback arguments to JavaScript-friendly arguments.\n    function cvtArgs(iUpdateType, dbName, tblName, lo32, hi32) {\n      return [\n        iUpdateType,\n        Module.UTF8ToString(dbName),\n        Module.UTF8ToString(tblName),\n\t\tcvt32x2ToBigInt(lo32, hi32)\n      ];\n    };\n    function adapt(f) {\n      return f instanceof AsyncFunction ?\n        (async (iUpdateType, dbName, tblName, lo32, hi32) => f(...cvtArgs(iUpdateType, dbName, tblName, lo32, hi32))) :\n        ((iUpdateType, dbName, tblName, lo32, hi32) => f(...cvtArgs(iUpdateType, dbName, tblName, lo32, hi32)));\n    }\n\n    Module.update_hook(db, adapt(xUpdateHook));\n  };;\n\n  sqlite3.value = function(pValue) {\n    const type = sqlite3.value_type(pValue);\n    switch (type) {\n      case SQLite.SQLITE_BLOB:\n        return sqlite3.value_blob(pValue);\n      case SQLite.SQLITE_FLOAT:\n        return sqlite3.value_double(pValue);\n      case SQLite.SQLITE_INTEGER:\n        const lo32 = sqlite3.value_int(pValue);\n        const hi32 = Module.getTempRet0();\n        return cvt32x2AsSafe(lo32, hi32);\n      case SQLite.SQLITE_NULL:\n        return null;\n      case SQLite.SQLITE_TEXT:\n        return sqlite3.value_text(pValue);\n      default:\n        throw new SQLiteError('unknown type', type);\n    }\n  };\n\n  sqlite3.value_blob = (function() {\n    const fname = 'sqlite3_value_blob';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const nBytes = sqlite3.value_bytes(pValue);\n      const address = f(pValue);\n      const result = Module.HEAPU8.subarray(address, address + nBytes);\n      return result;\n    };\n  })();\n\n  sqlite3.value_bytes = (function() {\n    const fname = 'sqlite3_value_bytes';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const result = f(pValue);\n      return result;\n    };\n  })();\n\n  sqlite3.value_double = (function() {\n    const fname = 'sqlite3_value_double';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const result = f(pValue);\n      return result;\n    };\n  })();\n\n  sqlite3.value_int = (function() {\n    const fname = 'sqlite3_value_int64';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const result = f(pValue);\n      return result;\n    };\n  })();\n\n  sqlite3.value_int64 = (function() {\n    const fname = 'sqlite3_value_int64';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const lo32 = f(pValue);\n      const hi32 = Module.getTempRet0();\n      const result = cvt32x2ToBigInt(lo32, hi32);\n      return result;\n    };\n  })();\n\n  sqlite3.value_text = (function() {\n    const fname = 'sqlite3_value_text';\n    const f = Module.cwrap(fname, ...decl('n:s'));\n    return function(pValue) {\n      const result = f(pValue);\n      return result;\n    };\n  })();\n\n  sqlite3.value_type = (function() {\n    const fname = 'sqlite3_value_type';\n    const f = Module.cwrap(fname, ...decl('n:n'));\n    return function(pValue) {\n      const result = f(pValue);\n      return result;\n    };\n  })();\n\n  sqlite3.vfs_register = function(vfs, makeDefault) {\n    const result = Module.vfs_register(vfs, makeDefault);\n    return check('sqlite3_vfs_register', result);\n  };\n\n  function check(fname, result, db = null, allowed = [SQLite.SQLITE_OK]) {\n    if (allowed.includes(result)) return result;\n    const message = db ? Module.ccall('sqlite3_errmsg', 'string', ['number'], [db]) : fname;\n    throw new SQLiteError(message, result);\n  }\n\n  // This function is used to automatically retry failed calls that\n  // have pending retry operations that should allow the retry to\n  // succeed.\n  async function retry(f) {\n    let rc;\n    do {\n      // Wait for all pending retry operations to complete. This is\n      // normally empty on the first loop iteration.\n      if (Module.retryOps.length) {\n        await Promise.all(Module.retryOps);\n        Module.retryOps = [];\n      }\n      \n      rc = await f();\n\n      // Retry on failure with new pending retry operations.\n    } while (rc && Module.retryOps.length);\n    return rc;\n  }\n\n  return sqlite3;\n}\n\n// Helper function to use a more compact signature specification.\nfunction decl(s) {\n  const result = [];\n  const m = s.match(/([ns@]*):([nsv@])/);\n  switch (m[2]) {\n    case 'n':\n      result.push('number');\n      break;\n    case 's':\n      result.push('string');\n      break;\n    case 'v':\n      result.push(null);\n      break;\n  }\n\n  const args = [];\n  for (let c of m[1]) {\n    switch (c) {\n      case 'n':\n        args.push('number');\n        break;\n      case 's':\n        args.push('string');\n        break;\n    }\n  }\n  result.push(args);\n  return result;\n}\n","// Primary result codes.\n// https://www.sqlite.org/rescode.html\nexport const SQLITE_OK = 0;\nexport const SQLITE_ERROR = 1;\nexport const SQLITE_INTERNAL = 2;\nexport const SQLITE_PERM = 3;\nexport const SQLITE_ABORT = 4;\nexport const SQLITE_BUSY = 5;\nexport const SQLITE_LOCKED = 6;\nexport const SQLITE_NOMEM = 7;\nexport const SQLITE_READONLY = 8;\nexport const SQLITE_INTERRUPT = 9;\nexport const SQLITE_IOERR = 10;\nexport const SQLITE_CORRUPT = 11;\nexport const SQLITE_NOTFOUND = 12;\nexport const SQLITE_FULL = 13;\nexport const SQLITE_CANTOPEN = 14;\nexport const SQLITE_PROTOCOL = 15;\nexport const SQLITE_EMPTY = 16;\nexport const SQLITE_SCHEMA = 17;\nexport const SQLITE_TOOBIG = 18;\nexport const SQLITE_CONSTRAINT = 19;\nexport const SQLITE_MISMATCH = 20;\nexport const SQLITE_MISUSE = 21;\nexport const SQLITE_NOLFS = 22;\nexport const SQLITE_AUTH = 23;\nexport const SQLITE_FORMAT = 24;\nexport const SQLITE_RANGE = 25;\nexport const SQLITE_NOTADB = 26;\nexport const SQLITE_NOTICE = 27;\nexport const SQLITE_WARNING = 28;\nexport const SQLITE_ROW = 100;\nexport const SQLITE_DONE = 101;\n\n// Extended error codes.\nexport const SQLITE_IOERR_ACCESS = 3338;\nexport const SQLITE_IOERR_CHECKRESERVEDLOCK = 3594;\nexport const SQLITE_IOERR_CLOSE = 4106;\nexport const SQLITE_IOERR_DATA = 8202;\nexport const SQLITE_IOERR_DELETE = 2570;\nexport const SQLITE_IOERR_DELETE_NOENT = 5898;\nexport const SQLITE_IOERR_DIR_FSYNC = 1290;\nexport const SQLITE_IOERR_FSTAT = 1802;\nexport const SQLITE_IOERR_FSYNC = 1034;\nexport const SQLITE_IOERR_GETTEMPPATH = 6410;\nexport const SQLITE_IOERR_LOCK = 3850;\nexport const SQLITE_IOERR_NOMEM = 3082;\nexport const SQLITE_IOERR_READ = 266;\nexport const SQLITE_IOERR_RDLOCK = 2314;\nexport const SQLITE_IOERR_SEEK = 5642;\nexport const SQLITE_IOERR_SHORT_READ = 522;\nexport const SQLITE_IOERR_TRUNCATE = 1546;\nexport const SQLITE_IOERR_UNLOCK = 2058;\nexport const SQLITE_IOERR_VNODE = 6922;\nexport const SQLITE_IOERR_WRITE = 778;\nexport const SQLITE_IOERR_BEGIN_ATOMIC = 7434;\nexport const SQLITE_IOERR_COMMIT_ATOMIC = 7690;\nexport const SQLITE_IOERR_ROLLBACK_ATOMIC = 7946;\n\n// Other extended result codes.\nexport const SQLITE_CONSTRAINT_CHECK = 275;\nexport const SQLITE_CONSTRAINT_COMMITHOOK = 531;\nexport const SQLITE_CONSTRAINT_FOREIGNKEY = 787;\nexport const SQLITE_CONSTRAINT_FUNCTION = 1043;\nexport const SQLITE_CONSTRAINT_NOTNULL = 1299;\nexport const SQLITE_CONSTRAINT_PINNED = 2835;\nexport const SQLITE_CONSTRAINT_PRIMARYKEY = 1555;\nexport const SQLITE_CONSTRAINT_ROWID = 2579;\nexport const SQLITE_CONSTRAINT_TRIGGER = 1811;\nexport const SQLITE_CONSTRAINT_UNIQUE = 2067;\nexport const SQLITE_CONSTRAINT_VTAB = 2323;\n\n// Open flags.\n// https://www.sqlite.org/c3ref/c_open_autoproxy.html\nexport const SQLITE_OPEN_READONLY = 0x00000001;\nexport const SQLITE_OPEN_READWRITE = 0x00000002;\nexport const SQLITE_OPEN_CREATE = 0x00000004;\nexport const SQLITE_OPEN_DELETEONCLOSE = 0x00000008;\nexport const SQLITE_OPEN_EXCLUSIVE = 0x00000010;\nexport const SQLITE_OPEN_AUTOPROXY = 0x00000020;\nexport const SQLITE_OPEN_URI = 0x00000040;\nexport const SQLITE_OPEN_MEMORY = 0x00000080;\nexport const SQLITE_OPEN_MAIN_DB = 0x00000100;\nexport const SQLITE_OPEN_TEMP_DB = 0x00000200;\nexport const SQLITE_OPEN_TRANSIENT_DB = 0x00000400;\nexport const SQLITE_OPEN_MAIN_JOURNAL = 0x00000800;\nexport const SQLITE_OPEN_TEMP_JOURNAL = 0x00001000;\nexport const SQLITE_OPEN_SUBJOURNAL = 0x00002000;\nexport const SQLITE_OPEN_SUPER_JOURNAL = 0x00004000;\nexport const SQLITE_OPEN_NOMUTEX = 0x00008000;\nexport const SQLITE_OPEN_FULLMUTEX = 0x00010000;\nexport const SQLITE_OPEN_SHAREDCACHE = 0x00020000;\nexport const SQLITE_OPEN_PRIVATECACHE = 0x00040000;\nexport const SQLITE_OPEN_WAL = 0x00080000;\nexport const SQLITE_OPEN_NOFOLLOW = 0x01000000;\n\n// Locking levels.\n// https://www.sqlite.org/c3ref/c_lock_exclusive.html\nexport const SQLITE_LOCK_NONE = 0;\nexport const SQLITE_LOCK_SHARED = 1;\nexport const SQLITE_LOCK_RESERVED = 2;\nexport const SQLITE_LOCK_PENDING = 3;\nexport const SQLITE_LOCK_EXCLUSIVE = 4;\n\n// Device characteristics.\n// https://www.sqlite.org/c3ref/c_iocap_atomic.html\nexport const SQLITE_IOCAP_ATOMIC = 0x00000001;\nexport const SQLITE_IOCAP_ATOMIC512 = 0x00000002;\nexport const SQLITE_IOCAP_ATOMIC1K = 0x00000004;\nexport const SQLITE_IOCAP_ATOMIC2K = 0x00000008;\nexport const SQLITE_IOCAP_ATOMIC4K = 0x00000010;\nexport const SQLITE_IOCAP_ATOMIC8K = 0x00000020;\nexport const SQLITE_IOCAP_ATOMIC16K = 0x00000040;\nexport const SQLITE_IOCAP_ATOMIC32K = 0x00000080;\nexport const SQLITE_IOCAP_ATOMIC64K = 0x00000100;\nexport const SQLITE_IOCAP_SAFE_APPEND = 0x00000200;\nexport const SQLITE_IOCAP_SEQUENTIAL = 0x00000400;\nexport const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN = 0x00000800;\nexport const SQLITE_IOCAP_POWERSAFE_OVERWRITE = 0x00001000;\nexport const SQLITE_IOCAP_IMMUTABLE = 0x00002000;\nexport const SQLITE_IOCAP_BATCH_ATOMIC = 0x00004000;\n\n// xAccess flags.\n// https://www.sqlite.org/c3ref/c_access_exists.html\nexport const SQLITE_ACCESS_EXISTS = 0;\nexport const SQLITE_ACCESS_READWRITE = 1;\nexport const SQLITE_ACCESS_READ = 2;\n\n// File control opcodes\n// https://www.sqlite.org/c3ref/c_fcntl_begin_atomic_write.html#sqlitefcntlbeginatomicwrite\nexport const SQLITE_FCNTL_LOCKSTATE = 1; \nexport const SQLITE_FCNTL_GET_LOCKPROXYFILE = 2; \nexport const SQLITE_FCNTL_SET_LOCKPROXYFILE = 3; \nexport const SQLITE_FCNTL_LAST_ERRNO = 4; \nexport const SQLITE_FCNTL_SIZE_HINT = 5; \nexport const SQLITE_FCNTL_CHUNK_SIZE = 6; \nexport const SQLITE_FCNTL_FILE_POINTER = 7; \nexport const SQLITE_FCNTL_SYNC_OMITTED = 8; \nexport const SQLITE_FCNTL_WIN32_AV_RETRY = 9; \nexport const SQLITE_FCNTL_PERSIST_WAL = 10; \nexport const SQLITE_FCNTL_OVERWRITE = 11; \nexport const SQLITE_FCNTL_VFSNAME = 12; \nexport const SQLITE_FCNTL_POWERSAFE_OVERWRITE = 13; \nexport const SQLITE_FCNTL_PRAGMA = 14; \nexport const SQLITE_FCNTL_BUSYHANDLER = 15; \nexport const SQLITE_FCNTL_TEMPFILENAME = 16; \nexport const SQLITE_FCNTL_MMAP_SIZE = 18; \nexport const SQLITE_FCNTL_TRACE = 19; \nexport const SQLITE_FCNTL_HAS_MOVED = 20; \nexport const SQLITE_FCNTL_SYNC = 21; \nexport const SQLITE_FCNTL_COMMIT_PHASETWO = 22; \nexport const SQLITE_FCNTL_WIN32_SET_HANDLE = 23; \nexport const SQLITE_FCNTL_WAL_BLOCK = 24; \nexport const SQLITE_FCNTL_ZIPVFS = 25; \nexport const SQLITE_FCNTL_RBU = 26; \nexport const SQLITE_FCNTL_VFS_POINTER = 27; \nexport const SQLITE_FCNTL_JOURNAL_POINTER = 28; \nexport const SQLITE_FCNTL_WIN32_GET_HANDLE = 29; \nexport const SQLITE_FCNTL_PDB = 30; \nexport const SQLITE_FCNTL_BEGIN_ATOMIC_WRITE = 31; \nexport const SQLITE_FCNTL_COMMIT_ATOMIC_WRITE = 32; \nexport const SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE = 33; \nexport const SQLITE_FCNTL_LOCK_TIMEOUT = 34; \nexport const SQLITE_FCNTL_DATA_VERSION = 35; \nexport const SQLITE_FCNTL_SIZE_LIMIT = 36; \nexport const SQLITE_FCNTL_CKPT_DONE = 37; \nexport const SQLITE_FCNTL_RESERVE_BYTES = 38; \nexport const SQLITE_FCNTL_CKPT_START = 39;\n\n// Fundamental datatypes.\n// https://www.sqlite.org/c3ref/c_blob.html\nexport const SQLITE_INTEGER = 1;\nexport const SQLITE_FLOAT = 2;\nexport const SQLITE_TEXT = 3;\nexport const SQLITE_BLOB = 4;\nexport const SQLITE_NULL = 5;\n\n// Special destructor behavior.\n// https://www.sqlite.org/c3ref/c_static.html\nexport const SQLITE_STATIC = 0;\nexport const SQLITE_TRANSIENT = -1;\n\n// Text encodings.\n// https://sqlite.org/c3ref/c_any.html\nexport const SQLITE_UTF8 = 1;     /* IMP: R-37514-35566 */\nexport const SQLITE_UTF16LE = 2;  /* IMP: R-03371-37637 */\nexport const SQLITE_UTF16BE = 3;  /* IMP: R-51971-34154 */\nexport const SQLITE_UTF16 = 4;    /* Use native byte order */\n\n// Module constraint ops.\nexport const SQLITE_INDEX_CONSTRAINT_EQ        = 2;\nexport const SQLITE_INDEX_CONSTRAINT_GT        = 4;\nexport const SQLITE_INDEX_CONSTRAINT_LE        = 8;\nexport const SQLITE_INDEX_CONSTRAINT_LT        = 16;\nexport const SQLITE_INDEX_CONSTRAINT_GE        = 32;\nexport const SQLITE_INDEX_CONSTRAINT_MATCH     = 64;\nexport const SQLITE_INDEX_CONSTRAINT_LIKE      = 65;\nexport const SQLITE_INDEX_CONSTRAINT_GLOB      = 66;\nexport const SQLITE_INDEX_CONSTRAINT_REGEXP    = 67;\nexport const SQLITE_INDEX_CONSTRAINT_NE        = 68;\nexport const SQLITE_INDEX_CONSTRAINT_ISNOT     = 69;\nexport const SQLITE_INDEX_CONSTRAINT_ISNOTNULL = 70;\nexport const SQLITE_INDEX_CONSTRAINT_ISNULL    = 71;\nexport const SQLITE_INDEX_CONSTRAINT_IS        = 72;\nexport const SQLITE_INDEX_CONSTRAINT_FUNCTION  = 150;\nexport const SQLITE_INDEX_SCAN_UNIQUE          = 1;  /* Scan visits at most = 1 row */\n\n// Function flags\nexport const SQLITE_DETERMINISTIC = 0x000000800;\nexport const SQLITE_DIRECTONLY    = 0x000080000;\nexport const SQLITE_SUBTYPE       = 0x000100000;\nexport const SQLITE_INNOCUOUS     = 0x000200000;\n\n// Sync flags\nexport const SQLITE_SYNC_NORMAL   = 0x00002;\nexport const SQLITE_SYNC_FULL     = 0x00003;\nexport const SQLITE_SYNC_DATAONLY = 0x00010;\n\n// Authorizer action codes\nexport const SQLITE_CREATE_INDEX        = 1;\nexport const SQLITE_CREATE_TABLE        = 2;\nexport const SQLITE_CREATE_TEMP_INDEX   = 3;\nexport const SQLITE_CREATE_TEMP_TABLE   = 4;\nexport const SQLITE_CREATE_TEMP_TRIGGER = 5;\nexport const SQLITE_CREATE_TEMP_VIEW    = 6;\nexport const SQLITE_CREATE_TRIGGER      = 7;\nexport const SQLITE_CREATE_VIEW         = 8;\nexport const SQLITE_DELETE              = 9;\nexport const SQLITE_DROP_INDEX          = 10;\nexport const SQLITE_DROP_TABLE          = 11;\nexport const SQLITE_DROP_TEMP_INDEX     = 12;\nexport const SQLITE_DROP_TEMP_TABLE     = 13;\nexport const SQLITE_DROP_TEMP_TRIGGER   = 14;\nexport const SQLITE_DROP_TEMP_VIEW      = 15;\nexport const SQLITE_DROP_TRIGGER        = 16;\nexport const SQLITE_DROP_VIEW           = 17;\nexport const SQLITE_INSERT              = 18;\nexport const SQLITE_PRAGMA              = 19;\nexport const SQLITE_READ                = 20;\nexport const SQLITE_SELECT              = 21;\nexport const SQLITE_TRANSACTION         = 22;\nexport const SQLITE_UPDATE              = 23;\nexport const SQLITE_ATTACH              = 24;\nexport const SQLITE_DETACH              = 25;\nexport const SQLITE_ALTER_TABLE         = 26;\nexport const SQLITE_REINDEX             = 27;\nexport const SQLITE_ANALYZE             = 28;\nexport const SQLITE_CREATE_VTABLE       = 29;\nexport const SQLITE_DROP_VTABLE         = 30;\nexport const SQLITE_FUNCTION            = 31;\nexport const SQLITE_SAVEPOINT           = 32;\nexport const SQLITE_COPY                = 0;\nexport const SQLITE_RECURSIVE           = 33;\n\n// Authorizer return codes\nexport const SQLITE_DENY   = 1;\nexport const SQLITE_IGNORE = 2;\n\n// Limit categories\nexport const SQLITE_LIMIT_LENGTH              = 0;\nexport const SQLITE_LIMIT_SQL_LENGTH          = 1;\nexport const SQLITE_LIMIT_COLUMN              = 2;\nexport const SQLITE_LIMIT_EXPR_DEPTH          = 3;\nexport const SQLITE_LIMIT_COMPOUND_SELECT     = 4;\nexport const SQLITE_LIMIT_VDBE_OP             = 5;\nexport const SQLITE_LIMIT_FUNCTION_ARG        = 6;\nexport const SQLITE_LIMIT_ATTACHED            = 7;\nexport const SQLITE_LIMIT_LIKE_PATTERN_LENGTH = 8;\nexport const SQLITE_LIMIT_VARIABLE_NUMBER     = 9;\nexport const SQLITE_LIMIT_TRIGGER_DEPTH       = 10;\nexport const SQLITE_LIMIT_WORKER_THREADS      = 11;\n\nexport const SQLITE_PREPARE_PERSISTENT = 0x01;\nexport const SQLITE_PREPARE_NORMALIZED = 0x02;\nexport const SQLITE_PREPARE_NO_VTAB = 0x04;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"worker/\" + chunkId + \".umd.js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl + \"../\";","__webpack_require__.b = self.location + \"/../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"WASQLiteDB\": 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunksdk_web\"] = self[\"webpackChunksdk_web\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","/**\n * Supports both shared and dedicated workers, based on how the worker is constructed (new SharedWorker vs new Worker()).\n */\nimport '@journeyapps/wa-sqlite';\nimport * as Comlink from 'comlink';\nimport { _openDB } from '../../shared/open-db';\nimport { getNavigatorLocks } from '../../shared/navigator';\nconst DBMap = new Map();\nconst OPEN_DB_LOCK = 'open-wasqlite-db';\nlet nextClientId = 1;\nconst openDBShared = async (dbFileName) => {\n    // Prevent multiple simultaneous opens from causing race conditions\n    return getNavigatorLocks().request(OPEN_DB_LOCK, async () => {\n        const clientId = nextClientId++;\n        if (!DBMap.has(dbFileName)) {\n            const clientIds = new Set();\n            const connection = await _openDB(dbFileName);\n            DBMap.set(dbFileName, {\n                clientIds,\n                db: connection\n            });\n        }\n        const dbEntry = DBMap.get(dbFileName);\n        dbEntry.clientIds.add(clientId);\n        const { db } = dbEntry;\n        const wrappedConnection = {\n            ...db,\n            close: Comlink.proxy(() => {\n                const { clientIds } = dbEntry;\n                clientIds.delete(clientId);\n                if (clientIds.size == 0) {\n                    console.debug(`Closing connection to ${dbFileName}.`);\n                    DBMap.delete(dbFileName);\n                    return db.close?.();\n                }\n                console.debug(`Connection to ${dbFileName} not closed yet due to active clients.`);\n            })\n        };\n        return Comlink.proxy(wrappedConnection);\n    });\n};\nconst openDBDedicated = async (dbFileName) => {\n    const connection = await _openDB(dbFileName);\n    return Comlink.proxy(connection);\n};\n// Check if we're in a SharedWorker context\nif (typeof SharedWorkerGlobalScope !== 'undefined') {\n    const _self = self;\n    _self.onconnect = function (event) {\n        const port = event.ports[0];\n        console.debug('Exposing shared db on port', port);\n        Comlink.expose(openDBShared, port);\n    };\n    addEventListener('unload', () => {\n        Array.from(DBMap.values()).forEach(async (dbConnection) => {\n            const db = await dbConnection.db;\n            db.close?.();\n        });\n    });\n}\nelse {\n    Comlink.expose(openDBDedicated);\n}\n"],"names":[],"sourceRoot":""}